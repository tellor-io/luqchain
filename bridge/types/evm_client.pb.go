// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: luqchain/bridge/evm_client.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type IAVLMerklePathHex struct {
	IsDataOnRight  bool   `protobuf:"varint,1,opt,name=is_data_on_right,json=isDataOnRight,proto3" json:"is_data_on_right,omitempty"`
	SubtreeHeight  uint32 `protobuf:"varint,2,opt,name=subtree_height,json=subtreeHeight,proto3" json:"subtree_height,omitempty"`
	SubtreeSize    uint64 `protobuf:"varint,3,opt,name=subtree_size,json=subtreeSize,proto3" json:"subtree_size,omitempty"`
	SubtreeVersion uint64 `protobuf:"varint,4,opt,name=subtree_version,json=subtreeVersion,proto3" json:"subtree_version,omitempty"`
	SiblingHash    string `protobuf:"bytes,5,opt,name=sibling_hash,json=siblingHash,proto3" json:"sibling_hash,omitempty"`
}

func (m *IAVLMerklePathHex) Reset()         { *m = IAVLMerklePathHex{} }
func (m *IAVLMerklePathHex) String() string { return proto.CompactTextString(m) }
func (*IAVLMerklePathHex) ProtoMessage()    {}
func (*IAVLMerklePathHex) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f5ee1287d1e654, []int{0}
}
func (m *IAVLMerklePathHex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IAVLMerklePathHex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IAVLMerklePathHex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IAVLMerklePathHex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IAVLMerklePathHex.Merge(m, src)
}
func (m *IAVLMerklePathHex) XXX_Size() int {
	return m.Size()
}
func (m *IAVLMerklePathHex) XXX_DiscardUnknown() {
	xxx_messageInfo_IAVLMerklePathHex.DiscardUnknown(m)
}

var xxx_messageInfo_IAVLMerklePathHex proto.InternalMessageInfo

func (m *IAVLMerklePathHex) GetIsDataOnRight() bool {
	if m != nil {
		return m.IsDataOnRight
	}
	return false
}

func (m *IAVLMerklePathHex) GetSubtreeHeight() uint32 {
	if m != nil {
		return m.SubtreeHeight
	}
	return 0
}

func (m *IAVLMerklePathHex) GetSubtreeSize() uint64 {
	if m != nil {
		return m.SubtreeSize
	}
	return 0
}

func (m *IAVLMerklePathHex) GetSubtreeVersion() uint64 {
	if m != nil {
		return m.SubtreeVersion
	}
	return 0
}

func (m *IAVLMerklePathHex) GetSiblingHash() string {
	if m != nil {
		return m.SiblingHash
	}
	return ""
}

type MulitstoreHex struct {
	LuqchainIavlStateHash            string `protobuf:"bytes,1,opt,name=luqchain_iavl_state_hash,json=luqchainIavlStateHash,proto3" json:"luqchain_iavl_state_hash,omitempty"`
	MintStoreMerkleHash              string `protobuf:"bytes,2,opt,name=mint_store_merkle_hash,json=mintStoreMerkleHash,proto3" json:"mint_store_merkle_hash,omitempty"`
	IcacontrollerToIcahostMerkleHash string `protobuf:"bytes,3,opt,name=icacontroller_to_icahost_merkle_hash,json=icacontrollerToIcahostMerkleHash,proto3" json:"icacontroller_to_icahost_merkle_hash,omitempty"`
	FeegrantToIbcMerkleHash          string `protobuf:"bytes,4,opt,name=feegrant_to_ibc_merkle_hash,json=feegrantToIbcMerkleHash,proto3" json:"feegrant_to_ibc_merkle_hash,omitempty"`
	AccToEvidenceMerkleHash          string `protobuf:"bytes,5,opt,name=acc_to_evidence_merkle_hash,json=accToEvidenceMerkleHash,proto3" json:"acc_to_evidence_merkle_hash,omitempty"`
	ParamsToVestingMerkleHash        string `protobuf:"bytes,6,opt,name=params_to_vesting_merkle_hash,json=paramsToVestingMerkleHash,proto3" json:"params_to_vesting_merkle_hash,omitempty"`
}

func (m *MulitstoreHex) Reset()         { *m = MulitstoreHex{} }
func (m *MulitstoreHex) String() string { return proto.CompactTextString(m) }
func (*MulitstoreHex) ProtoMessage()    {}
func (*MulitstoreHex) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f5ee1287d1e654, []int{1}
}
func (m *MulitstoreHex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MulitstoreHex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MulitstoreHex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MulitstoreHex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MulitstoreHex.Merge(m, src)
}
func (m *MulitstoreHex) XXX_Size() int {
	return m.Size()
}
func (m *MulitstoreHex) XXX_DiscardUnknown() {
	xxx_messageInfo_MulitstoreHex.DiscardUnknown(m)
}

var xxx_messageInfo_MulitstoreHex proto.InternalMessageInfo

func (m *MulitstoreHex) GetLuqchainIavlStateHash() string {
	if m != nil {
		return m.LuqchainIavlStateHash
	}
	return ""
}

func (m *MulitstoreHex) GetMintStoreMerkleHash() string {
	if m != nil {
		return m.MintStoreMerkleHash
	}
	return ""
}

func (m *MulitstoreHex) GetIcacontrollerToIcahostMerkleHash() string {
	if m != nil {
		return m.IcacontrollerToIcahostMerkleHash
	}
	return ""
}

func (m *MulitstoreHex) GetFeegrantToIbcMerkleHash() string {
	if m != nil {
		return m.FeegrantToIbcMerkleHash
	}
	return ""
}

func (m *MulitstoreHex) GetAccToEvidenceMerkleHash() string {
	if m != nil {
		return m.AccToEvidenceMerkleHash
	}
	return ""
}

func (m *MulitstoreHex) GetParamsToVestingMerkleHash() string {
	if m != nil {
		return m.ParamsToVestingMerkleHash
	}
	return ""
}

type BlockHeaderHex struct {
	VersionChainidHash         string `protobuf:"bytes,1,opt,name=versionChainidHash,proto3" json:"versionChainidHash,omitempty"`
	Height                     uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	TimeSecond                 uint64 `protobuf:"varint,3,opt,name=timeSecond,proto3" json:"timeSecond,omitempty"`
	TimeNanosecond             uint32 `protobuf:"varint,4,opt,name=timeNanosecond,proto3" json:"timeNanosecond,omitempty"`
	LastblockidCommitHash      string `protobuf:"bytes,5,opt,name=lastblockidCommitHash,proto3" json:"lastblockidCommitHash,omitempty"`
	NextvalidatorConsensusHash string `protobuf:"bytes,6,opt,name=nextvalidatorConsensusHash,proto3" json:"nextvalidatorConsensusHash,omitempty"`
	LastresultsHash            string `protobuf:"bytes,7,opt,name=lastresultsHash,proto3" json:"lastresultsHash,omitempty"`
	EvidenceProposerHash       string `protobuf:"bytes,8,opt,name=evidenceProposerHash,proto3" json:"evidenceProposerHash,omitempty"`
}

func (m *BlockHeaderHex) Reset()         { *m = BlockHeaderHex{} }
func (m *BlockHeaderHex) String() string { return proto.CompactTextString(m) }
func (*BlockHeaderHex) ProtoMessage()    {}
func (*BlockHeaderHex) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f5ee1287d1e654, []int{2}
}
func (m *BlockHeaderHex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockHeaderHex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockHeaderHex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockHeaderHex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockHeaderHex.Merge(m, src)
}
func (m *BlockHeaderHex) XXX_Size() int {
	return m.Size()
}
func (m *BlockHeaderHex) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockHeaderHex.DiscardUnknown(m)
}

var xxx_messageInfo_BlockHeaderHex proto.InternalMessageInfo

func (m *BlockHeaderHex) GetVersionChainidHash() string {
	if m != nil {
		return m.VersionChainidHash
	}
	return ""
}

func (m *BlockHeaderHex) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BlockHeaderHex) GetTimeSecond() uint64 {
	if m != nil {
		return m.TimeSecond
	}
	return 0
}

func (m *BlockHeaderHex) GetTimeNanosecond() uint32 {
	if m != nil {
		return m.TimeNanosecond
	}
	return 0
}

func (m *BlockHeaderHex) GetLastblockidCommitHash() string {
	if m != nil {
		return m.LastblockidCommitHash
	}
	return ""
}

func (m *BlockHeaderHex) GetNextvalidatorConsensusHash() string {
	if m != nil {
		return m.NextvalidatorConsensusHash
	}
	return ""
}

func (m *BlockHeaderHex) GetLastresultsHash() string {
	if m != nil {
		return m.LastresultsHash
	}
	return ""
}

func (m *BlockHeaderHex) GetEvidenceProposerHash() string {
	if m != nil {
		return m.EvidenceProposerHash
	}
	return ""
}

type CommonHex struct {
	SignedDataPrefix string `protobuf:"bytes,1,opt,name=SignedDataPrefix,proto3" json:"SignedDataPrefix,omitempty"`
	SignedDataSuffix string `protobuf:"bytes,2,opt,name=SignedDataSuffix,proto3" json:"SignedDataSuffix,omitempty"`
}

func (m *CommonHex) Reset()         { *m = CommonHex{} }
func (m *CommonHex) String() string { return proto.CompactTextString(m) }
func (*CommonHex) ProtoMessage()    {}
func (*CommonHex) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f5ee1287d1e654, []int{3}
}
func (m *CommonHex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonHex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonHex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonHex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonHex.Merge(m, src)
}
func (m *CommonHex) XXX_Size() int {
	return m.Size()
}
func (m *CommonHex) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonHex.DiscardUnknown(m)
}

var xxx_messageInfo_CommonHex proto.InternalMessageInfo

func (m *CommonHex) GetSignedDataPrefix() string {
	if m != nil {
		return m.SignedDataPrefix
	}
	return ""
}

func (m *CommonHex) GetSignedDataSuffix() string {
	if m != nil {
		return m.SignedDataSuffix
	}
	return ""
}

type TmSigHex struct {
	R                string `protobuf:"bytes,1,opt,name=R,proto3" json:"R,omitempty"`
	S                string `protobuf:"bytes,2,opt,name=S,proto3" json:"S,omitempty"`
	V                uint32 `protobuf:"varint,3,opt,name=V,proto3" json:"V,omitempty"`
	EncodedTimestamp string `protobuf:"bytes,4,opt,name=EncodedTimestamp,proto3" json:"EncodedTimestamp,omitempty"`
}

func (m *TmSigHex) Reset()         { *m = TmSigHex{} }
func (m *TmSigHex) String() string { return proto.CompactTextString(m) }
func (*TmSigHex) ProtoMessage()    {}
func (*TmSigHex) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f5ee1287d1e654, []int{4}
}
func (m *TmSigHex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TmSigHex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TmSigHex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TmSigHex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TmSigHex.Merge(m, src)
}
func (m *TmSigHex) XXX_Size() int {
	return m.Size()
}
func (m *TmSigHex) XXX_DiscardUnknown() {
	xxx_messageInfo_TmSigHex.DiscardUnknown(m)
}

var xxx_messageInfo_TmSigHex proto.InternalMessageInfo

func (m *TmSigHex) GetR() string {
	if m != nil {
		return m.R
	}
	return ""
}

func (m *TmSigHex) GetS() string {
	if m != nil {
		return m.S
	}
	return ""
}

func (m *TmSigHex) GetV() uint32 {
	if m != nil {
		return m.V
	}
	return 0
}

func (m *TmSigHex) GetEncodedTimestamp() string {
	if m != nil {
		return m.EncodedTimestamp
	}
	return ""
}

type Report struct {
	Qdata     string `protobuf:"bytes,1,opt,name=qdata,proto3" json:"qdata,omitempty"`
	Value     uint64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	Timestamp uint64 `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *Report) Reset()         { *m = Report{} }
func (m *Report) String() string { return proto.CompactTextString(m) }
func (*Report) ProtoMessage()    {}
func (*Report) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f5ee1287d1e654, []int{5}
}
func (m *Report) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Report) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Report.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Report) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Report.Merge(m, src)
}
func (m *Report) XXX_Size() int {
	return m.Size()
}
func (m *Report) XXX_DiscardUnknown() {
	xxx_messageInfo_Report.DiscardUnknown(m)
}

var xxx_messageInfo_Report proto.InternalMessageInfo

func (m *Report) GetQdata() string {
	if m != nil {
		return m.Qdata
	}
	return ""
}

func (m *Report) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *Report) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type Proof struct {
	BlockHeight     uint64           `protobuf:"varint,1,opt,name=blockHeight,proto3" json:"blockHeight,omitempty"`
	ReportDataProof *ReportDataProof `protobuf:"bytes,2,opt,name=reportDataProof,proto3" json:"reportDataProof,omitempty"`
	BlockRelayProof *BlockRelayProof `protobuf:"bytes,3,opt,name=blockRelayProof,proto3" json:"blockRelayProof,omitempty"`
}

func (m *Proof) Reset()         { *m = Proof{} }
func (m *Proof) String() string { return proto.CompactTextString(m) }
func (*Proof) ProtoMessage()    {}
func (*Proof) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f5ee1287d1e654, []int{6}
}
func (m *Proof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proof.Merge(m, src)
}
func (m *Proof) XXX_Size() int {
	return m.Size()
}
func (m *Proof) XXX_DiscardUnknown() {
	xxx_messageInfo_Proof.DiscardUnknown(m)
}

var xxx_messageInfo_Proof proto.InternalMessageInfo

func (m *Proof) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *Proof) GetReportDataProof() *ReportDataProof {
	if m != nil {
		return m.ReportDataProof
	}
	return nil
}

func (m *Proof) GetBlockRelayProof() *BlockRelayProof {
	if m != nil {
		return m.BlockRelayProof
	}
	return nil
}

type BlockRelayProof struct {
	MultistoreProof        MulitstoreHex  `protobuf:"bytes,1,opt,name=MultistoreProof,proto3" json:"MultistoreProof"`
	BlockHeaderMerkleParts BlockHeaderHex `protobuf:"bytes,2,opt,name=blockHeaderMerkleParts,proto3" json:"blockHeaderMerkleParts"`
	CommonEncodedVotePart  CommonHex      `protobuf:"bytes,3,opt,name=commonEncodedVotePart,proto3" json:"commonEncodedVotePart"`
	Signatures             []TmSigHex     `protobuf:"bytes,4,rep,name=Signatures,proto3" json:"Signatures"`
	AppHash                string         `protobuf:"bytes,5,opt,name=appHash,proto3" json:"appHash,omitempty"`
	HeaderHash             string         `protobuf:"bytes,6,opt,name=headerHash,proto3" json:"headerHash,omitempty"`
	CommonVote             string         `protobuf:"bytes,7,opt,name=commonVote,proto3" json:"commonVote,omitempty"`
}

func (m *BlockRelayProof) Reset()         { *m = BlockRelayProof{} }
func (m *BlockRelayProof) String() string { return proto.CompactTextString(m) }
func (*BlockRelayProof) ProtoMessage()    {}
func (*BlockRelayProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f5ee1287d1e654, []int{7}
}
func (m *BlockRelayProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockRelayProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockRelayProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockRelayProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRelayProof.Merge(m, src)
}
func (m *BlockRelayProof) XXX_Size() int {
	return m.Size()
}
func (m *BlockRelayProof) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRelayProof.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRelayProof proto.InternalMessageInfo

func (m *BlockRelayProof) GetMultistoreProof() MulitstoreHex {
	if m != nil {
		return m.MultistoreProof
	}
	return MulitstoreHex{}
}

func (m *BlockRelayProof) GetBlockHeaderMerkleParts() BlockHeaderHex {
	if m != nil {
		return m.BlockHeaderMerkleParts
	}
	return BlockHeaderHex{}
}

func (m *BlockRelayProof) GetCommonEncodedVotePart() CommonHex {
	if m != nil {
		return m.CommonEncodedVotePart
	}
	return CommonHex{}
}

func (m *BlockRelayProof) GetSignatures() []TmSigHex {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *BlockRelayProof) GetAppHash() string {
	if m != nil {
		return m.AppHash
	}
	return ""
}

func (m *BlockRelayProof) GetHeaderHash() string {
	if m != nil {
		return m.HeaderHash
	}
	return ""
}

func (m *BlockRelayProof) GetCommonVote() string {
	if m != nil {
		return m.CommonVote
	}
	return ""
}

type ReportDataProof struct {
	DataKey     string              `protobuf:"bytes,1,opt,name=dataKey,proto3" json:"dataKey,omitempty"`
	Report      Report              `protobuf:"bytes,2,opt,name=report,proto3" json:"report"`
	Version     uint64              `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	MerklePaths []IAVLMerklePathHex `protobuf:"bytes,4,rep,name=merklePaths,proto3" json:"merklePaths"`
}

func (m *ReportDataProof) Reset()         { *m = ReportDataProof{} }
func (m *ReportDataProof) String() string { return proto.CompactTextString(m) }
func (*ReportDataProof) ProtoMessage()    {}
func (*ReportDataProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f5ee1287d1e654, []int{8}
}
func (m *ReportDataProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportDataProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportDataProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportDataProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportDataProof.Merge(m, src)
}
func (m *ReportDataProof) XXX_Size() int {
	return m.Size()
}
func (m *ReportDataProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportDataProof.DiscardUnknown(m)
}

var xxx_messageInfo_ReportDataProof proto.InternalMessageInfo

func (m *ReportDataProof) GetDataKey() string {
	if m != nil {
		return m.DataKey
	}
	return ""
}

func (m *ReportDataProof) GetReport() Report {
	if m != nil {
		return m.Report
	}
	return Report{}
}

func (m *ReportDataProof) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ReportDataProof) GetMerklePaths() []IAVLMerklePathHex {
	if m != nil {
		return m.MerklePaths
	}
	return nil
}

func init() {
	proto.RegisterType((*IAVLMerklePathHex)(nil), "luqchain.bridge.IAVLMerklePathHex")
	proto.RegisterType((*MulitstoreHex)(nil), "luqchain.bridge.MulitstoreHex")
	proto.RegisterType((*BlockHeaderHex)(nil), "luqchain.bridge.BlockHeaderHex")
	proto.RegisterType((*CommonHex)(nil), "luqchain.bridge.CommonHex")
	proto.RegisterType((*TmSigHex)(nil), "luqchain.bridge.TmSigHex")
	proto.RegisterType((*Report)(nil), "luqchain.bridge.Report")
	proto.RegisterType((*Proof)(nil), "luqchain.bridge.Proof")
	proto.RegisterType((*BlockRelayProof)(nil), "luqchain.bridge.BlockRelayProof")
	proto.RegisterType((*ReportDataProof)(nil), "luqchain.bridge.ReportDataProof")
}

func init() { proto.RegisterFile("luqchain/bridge/evm_client.proto", fileDescriptor_60f5ee1287d1e654) }

var fileDescriptor_60f5ee1287d1e654 = []byte{
	// 996 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x18, 0xad, 0x9b, 0x6c, 0xb6, 0xfd, 0xb2, 0x69, 0x96, 0xa1, 0x3f, 0xd9, 0x02, 0xd9, 0x60, 0x01,
	0x1b, 0x71, 0x91, 0x4a, 0x5d, 0x10, 0x37, 0x88, 0x9f, 0x96, 0x95, 0xd2, 0x85, 0x96, 0xca, 0x89,
	0x72, 0x81, 0x84, 0xcc, 0xc4, 0x9e, 0x24, 0xa3, 0xb5, 0x3d, 0xd9, 0x99, 0x49, 0xd4, 0xee, 0x2b,
	0x70, 0xc3, 0xbb, 0xf0, 0x04, 0xdc, 0xf5, 0x72, 0xc5, 0x15, 0x57, 0x08, 0xb5, 0xaf, 0xc0, 0x03,
	0xa0, 0xf9, 0x71, 0x62, 0x3b, 0x29, 0x77, 0xf9, 0xce, 0x77, 0xce, 0x19, 0xfb, 0x9b, 0x33, 0x13,
	0x43, 0x2b, 0x9a, 0xbd, 0x0e, 0x26, 0x98, 0x26, 0x47, 0x43, 0x4e, 0xc3, 0x31, 0x39, 0x22, 0xf3,
	0xd8, 0x0f, 0x22, 0x4a, 0x12, 0xd9, 0x99, 0x72, 0x26, 0x19, 0xaa, 0xa7, 0x8c, 0x8e, 0x61, 0x1c,
	0xee, 0x8e, 0xd9, 0x98, 0xe9, 0xde, 0x91, 0xfa, 0x65, 0x68, 0xee, 0x9f, 0x0e, 0xbc, 0x73, 0xf6,
	0xed, 0xe0, 0x87, 0x73, 0xc2, 0x5f, 0x45, 0xe4, 0x12, 0xcb, 0x49, 0x97, 0x5c, 0xa1, 0x67, 0xf0,
	0x98, 0x0a, 0x3f, 0xc4, 0x12, 0xfb, 0x2c, 0xf1, 0x39, 0x1d, 0x4f, 0x64, 0xc3, 0x69, 0x39, 0xed,
	0x2d, 0xaf, 0x46, 0xc5, 0x77, 0x58, 0xe2, 0x1f, 0x13, 0x4f, 0x81, 0xe8, 0x63, 0xd8, 0x11, 0xb3,
	0xa1, 0xe4, 0x84, 0xf8, 0x13, 0xa2, 0x69, 0x9b, 0x2d, 0xa7, 0x5d, 0xf3, 0x6a, 0x16, 0xed, 0x6a,
	0x10, 0x7d, 0x08, 0x8f, 0x52, 0x9a, 0xa0, 0x6f, 0x48, 0xa3, 0xd4, 0x72, 0xda, 0x65, 0xaf, 0x6a,
	0xb1, 0x1e, 0x7d, 0x43, 0xd0, 0x33, 0xa8, 0xa7, 0x94, 0x39, 0xe1, 0x82, 0xb2, 0xa4, 0x51, 0xd6,
	0xac, 0x74, 0x81, 0x81, 0x41, 0xb5, 0x17, 0x1d, 0x46, 0x34, 0x19, 0xfb, 0x13, 0x2c, 0x26, 0x8d,
	0x07, 0x2d, 0xa7, 0xbd, 0xed, 0x55, 0x2d, 0xd6, 0xc5, 0x62, 0xe2, 0xfe, 0x5a, 0x82, 0xda, 0xf9,
	0x2c, 0xa2, 0x52, 0x48, 0xc6, 0x89, 0x7a, 0xa1, 0x2f, 0xa0, 0x91, 0xce, 0xc3, 0xa7, 0x78, 0x1e,
	0xf9, 0x42, 0x62, 0x49, 0x8c, 0x81, 0xa3, 0x0d, 0xf6, 0xd2, 0xfe, 0x19, 0x9e, 0x47, 0x3d, 0xd5,
	0x55, 0x56, 0xe8, 0x39, 0xec, 0xc7, 0x34, 0x91, 0xbe, 0x76, 0xf2, 0x63, 0x3d, 0x25, 0x23, 0xdb,
	0xd4, 0xb2, 0x77, 0x55, 0xb7, 0xa7, 0x9a, 0x66, 0x82, 0x5a, 0x74, 0x01, 0x1f, 0xd1, 0x00, 0x07,
	0x2c, 0x91, 0x9c, 0x45, 0x11, 0xe1, 0xbe, 0x64, 0x3e, 0x0d, 0xf0, 0x84, 0x09, 0x99, 0xb3, 0x28,
	0x69, 0x8b, 0x56, 0x8e, 0xdb, 0x67, 0x67, 0x86, 0x99, 0xf1, 0xfb, 0x12, 0xde, 0x1b, 0x11, 0x32,
	0xe6, 0x38, 0x91, 0xda, 0x6a, 0x18, 0xe4, 0x6c, 0xca, 0xda, 0xe6, 0x20, 0xa5, 0xf4, 0xd9, 0xd9,
	0x30, 0xc8, 0xab, 0x71, 0x10, 0x28, 0x21, 0x99, 0xd3, 0x90, 0x24, 0x41, 0xfe, 0x3d, 0xcc, 0xfc,
	0x0e, 0x70, 0x10, 0xf4, 0xd9, 0x0b, 0x4b, 0xc8, 0xa8, 0xbf, 0x81, 0x0f, 0xa6, 0x98, 0xe3, 0x58,
	0x28, 0x83, 0x39, 0x11, 0x52, 0x0d, 0x3e, 0xab, 0xaf, 0x68, 0xfd, 0x13, 0x43, 0xea, 0xb3, 0x81,
	0xa1, 0x2c, 0x1d, 0xdc, 0x7f, 0x37, 0x61, 0xe7, 0x24, 0x62, 0xc1, 0xab, 0x2e, 0xc1, 0x21, 0xe1,
	0x6a, 0x3b, 0x3a, 0x80, 0xec, 0x26, 0x9f, 0xaa, 0x91, 0xd3, 0xb0, 0xbb, 0xdc, 0x88, 0x35, 0x1d,
	0xb4, 0x0f, 0x95, 0x4c, 0xbc, 0xca, 0x9e, 0xad, 0x50, 0x13, 0x40, 0xd2, 0x98, 0xf4, 0x48, 0xc0,
	0x92, 0xd0, 0xa6, 0x2a, 0x83, 0xa0, 0x4f, 0x60, 0x47, 0x55, 0x17, 0x38, 0x61, 0xc2, 0x70, 0xca,
	0x3a, 0x9e, 0x05, 0x14, 0x7d, 0x06, 0x7b, 0x11, 0x16, 0x72, 0xa8, 0x9e, 0x92, 0x86, 0xa7, 0x2c,
	0x8e, 0xa9, 0xec, 0x2e, 0x87, 0xb3, 0xbe, 0x89, 0xbe, 0x82, 0xc3, 0x84, 0x5c, 0xc9, 0x39, 0x8e,
	0x68, 0x88, 0x25, 0xe3, 0xa7, 0x2c, 0x11, 0x24, 0x11, 0x33, 0xd1, 0x5d, 0xce, 0xe5, 0x7f, 0x18,
	0xa8, 0x0d, 0x75, 0x65, 0xcc, 0x89, 0x98, 0x45, 0xd2, 0x88, 0x1e, 0x6a, 0x51, 0x11, 0x46, 0xc7,
	0xb0, 0x9b, 0xee, 0xdd, 0x25, 0x67, 0x53, 0x26, 0x08, 0xd7, 0xf4, 0x2d, 0x4d, 0x5f, 0xdb, 0x73,
	0x03, 0xd8, 0x56, 0xcf, 0xca, 0x12, 0x35, 0xf0, 0x4f, 0xe1, 0x71, 0x8f, 0x8e, 0x13, 0x12, 0xaa,
	0xc3, 0x7b, 0xc9, 0xc9, 0x88, 0x5e, 0xd9, 0x71, 0xaf, 0xe0, 0x79, 0x6e, 0x6f, 0x36, 0x52, 0xdc,
	0xcd, 0x22, 0xd7, 0xe0, 0xee, 0x2f, 0xb0, 0xd5, 0x8f, 0x7b, 0x74, 0xac, 0xd6, 0x78, 0x04, 0x8e,
	0x67, 0x4d, 0x1d, 0x4f, 0x55, 0x3d, 0x2b, 0x73, 0x7a, 0xaa, 0x1a, 0xe8, 0xfd, 0xa9, 0x79, 0xce,
	0x40, 0xad, 0xf0, 0x22, 0x09, 0x58, 0x48, 0xc2, 0x3e, 0x8d, 0x89, 0x90, 0x38, 0x9e, 0xda, 0x10,
	0xaf, 0xe0, 0xae, 0x07, 0x15, 0x8f, 0x4c, 0x19, 0x97, 0x68, 0x17, 0x1e, 0xbc, 0x56, 0x57, 0x92,
	0x5d, 0xc3, 0x14, 0x0a, 0x9d, 0xe3, 0x68, 0x46, 0x6c, 0x32, 0x4c, 0x81, 0xde, 0x87, 0x6d, 0xb9,
	0xb0, 0x36, 0xb9, 0x58, 0x02, 0xee, 0x1f, 0x0e, 0x3c, 0xb8, 0xe4, 0x8c, 0x8d, 0x50, 0x0b, 0xaa,
	0x43, 0x13, 0xcd, 0xc5, 0x1d, 0x57, 0xf6, 0xb2, 0x10, 0x7a, 0x09, 0x75, 0xae, 0xd7, 0x37, 0x13,
	0x62, 0x6c, 0xa4, 0x57, 0xaa, 0x1e, 0xb7, 0x3a, 0x85, 0x1b, 0xb6, 0xe3, 0xe5, 0x79, 0x5e, 0x51,
	0xa8, 0xbc, 0xb4, 0xb5, 0x47, 0x22, 0x7c, 0x6d, 0xbc, 0x4a, 0xf7, 0x78, 0x9d, 0xe4, 0x79, 0x5e,
	0x51, 0xe8, 0xfe, 0x5e, 0x82, 0x7a, 0x81, 0x84, 0x2e, 0xa0, 0x7e, 0x3e, 0x8b, 0x24, 0xd5, 0x97,
	0x95, 0xf1, 0x77, 0xb4, 0x7f, 0x73, 0xc5, 0x3f, 0x77, 0x3d, 0x9e, 0x94, 0x6f, 0xfe, 0x7e, 0xba,
	0xe1, 0x15, 0xc5, 0xe8, 0x67, 0xd8, 0x1f, 0x2e, 0x0f, 0x6e, 0xfa, 0x17, 0xc1, 0xa5, 0xb0, 0x23,
	0x78, 0xba, 0xfe, 0xb1, 0x17, 0xe7, 0xdc, 0xfa, 0xde, 0x63, 0x82, 0x06, 0xb0, 0x17, 0xe8, 0x84,
	0xda, 0x4d, 0x1f, 0x30, 0xa9, 0x3b, 0x76, 0x28, 0x87, 0x2b, 0xee, 0x8b, 0x3c, 0x5b, 0xe3, 0xf5,
	0x72, 0xf4, 0x35, 0x80, 0x0a, 0x2a, 0x96, 0x33, 0x4e, 0x44, 0xa3, 0xdc, 0x2a, 0xb5, 0xab, 0xc7,
	0x4f, 0x56, 0xcc, 0xd2, 0xdc, 0x5a, 0xaf, 0x8c, 0x04, 0x35, 0xe0, 0x21, 0x9e, 0x4e, 0x33, 0x17,
	0x40, 0x5a, 0xaa, 0x0b, 0x67, 0x62, 0xde, 0x6e, 0x79, 0xc4, 0x33, 0x88, 0xea, 0x9b, 0x67, 0x52,
	0x0f, 0x63, 0x4f, 0x73, 0x06, 0x71, 0x6f, 0x1c, 0xa8, 0x17, 0x62, 0xa2, 0x56, 0x53, 0x49, 0xfe,
	0x9e, 0x5c, 0xdb, 0x64, 0xa7, 0x25, 0xfa, 0x1c, 0x2a, 0x26, 0x42, 0x76, 0xde, 0x07, 0xf7, 0x44,
	0xce, 0xbe, 0x82, 0x25, 0x2b, 0xc3, 0xf4, 0x2f, 0xd4, 0x44, 0x3f, 0x2d, 0xd1, 0x4b, 0xa8, 0xc6,
	0x8b, 0x3f, 0xfa, 0x74, 0x34, 0xee, 0x8a, 0xeb, 0xca, 0x07, 0x81, 0x5d, 0x20, 0x2b, 0x3e, 0x39,
	0xba, 0xb9, 0x6d, 0x3a, 0x6f, 0x6f, 0x9b, 0xce, 0x3f, 0xb7, 0x4d, 0xe7, 0xb7, 0xbb, 0xe6, 0xc6,
	0xdb, 0xbb, 0xe6, 0xc6, 0x5f, 0x77, 0xcd, 0x8d, 0x9f, 0xf6, 0x8a, 0x1f, 0x27, 0xf2, 0x7a, 0x4a,
	0xc4, 0xb0, 0xa2, 0xbf, 0x38, 0x9e, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0xf8, 0x2a, 0xc1, 0x00,
	0xbc, 0x08, 0x00, 0x00,
}

func (m *IAVLMerklePathHex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IAVLMerklePathHex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IAVLMerklePathHex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SiblingHash) > 0 {
		i -= len(m.SiblingHash)
		copy(dAtA[i:], m.SiblingHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.SiblingHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SubtreeVersion != 0 {
		i = encodeVarintEvmClient(dAtA, i, uint64(m.SubtreeVersion))
		i--
		dAtA[i] = 0x20
	}
	if m.SubtreeSize != 0 {
		i = encodeVarintEvmClient(dAtA, i, uint64(m.SubtreeSize))
		i--
		dAtA[i] = 0x18
	}
	if m.SubtreeHeight != 0 {
		i = encodeVarintEvmClient(dAtA, i, uint64(m.SubtreeHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.IsDataOnRight {
		i--
		if m.IsDataOnRight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MulitstoreHex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MulitstoreHex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MulitstoreHex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParamsToVestingMerkleHash) > 0 {
		i -= len(m.ParamsToVestingMerkleHash)
		copy(dAtA[i:], m.ParamsToVestingMerkleHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.ParamsToVestingMerkleHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AccToEvidenceMerkleHash) > 0 {
		i -= len(m.AccToEvidenceMerkleHash)
		copy(dAtA[i:], m.AccToEvidenceMerkleHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.AccToEvidenceMerkleHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FeegrantToIbcMerkleHash) > 0 {
		i -= len(m.FeegrantToIbcMerkleHash)
		copy(dAtA[i:], m.FeegrantToIbcMerkleHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.FeegrantToIbcMerkleHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IcacontrollerToIcahostMerkleHash) > 0 {
		i -= len(m.IcacontrollerToIcahostMerkleHash)
		copy(dAtA[i:], m.IcacontrollerToIcahostMerkleHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.IcacontrollerToIcahostMerkleHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MintStoreMerkleHash) > 0 {
		i -= len(m.MintStoreMerkleHash)
		copy(dAtA[i:], m.MintStoreMerkleHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.MintStoreMerkleHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LuqchainIavlStateHash) > 0 {
		i -= len(m.LuqchainIavlStateHash)
		copy(dAtA[i:], m.LuqchainIavlStateHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.LuqchainIavlStateHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockHeaderHex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockHeaderHex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockHeaderHex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvidenceProposerHash) > 0 {
		i -= len(m.EvidenceProposerHash)
		copy(dAtA[i:], m.EvidenceProposerHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.EvidenceProposerHash)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.LastresultsHash) > 0 {
		i -= len(m.LastresultsHash)
		copy(dAtA[i:], m.LastresultsHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.LastresultsHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.NextvalidatorConsensusHash) > 0 {
		i -= len(m.NextvalidatorConsensusHash)
		copy(dAtA[i:], m.NextvalidatorConsensusHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.NextvalidatorConsensusHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.LastblockidCommitHash) > 0 {
		i -= len(m.LastblockidCommitHash)
		copy(dAtA[i:], m.LastblockidCommitHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.LastblockidCommitHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TimeNanosecond != 0 {
		i = encodeVarintEvmClient(dAtA, i, uint64(m.TimeNanosecond))
		i--
		dAtA[i] = 0x20
	}
	if m.TimeSecond != 0 {
		i = encodeVarintEvmClient(dAtA, i, uint64(m.TimeSecond))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintEvmClient(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.VersionChainidHash) > 0 {
		i -= len(m.VersionChainidHash)
		copy(dAtA[i:], m.VersionChainidHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.VersionChainidHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommonHex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonHex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonHex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SignedDataSuffix) > 0 {
		i -= len(m.SignedDataSuffix)
		copy(dAtA[i:], m.SignedDataSuffix)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.SignedDataSuffix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SignedDataPrefix) > 0 {
		i -= len(m.SignedDataPrefix)
		copy(dAtA[i:], m.SignedDataPrefix)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.SignedDataPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TmSigHex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TmSigHex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TmSigHex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncodedTimestamp) > 0 {
		i -= len(m.EncodedTimestamp)
		copy(dAtA[i:], m.EncodedTimestamp)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.EncodedTimestamp)))
		i--
		dAtA[i] = 0x22
	}
	if m.V != 0 {
		i = encodeVarintEvmClient(dAtA, i, uint64(m.V))
		i--
		dAtA[i] = 0x18
	}
	if len(m.S) > 0 {
		i -= len(m.S)
		copy(dAtA[i:], m.S)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.S)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.R) > 0 {
		i -= len(m.R)
		copy(dAtA[i:], m.R)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.R)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Report) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Report) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Report) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintEvmClient(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x18
	}
	if m.Value != 0 {
		i = encodeVarintEvmClient(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Qdata) > 0 {
		i -= len(m.Qdata)
		copy(dAtA[i:], m.Qdata)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.Qdata)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Proof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockRelayProof != nil {
		{
			size, err := m.BlockRelayProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvmClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ReportDataProof != nil {
		{
			size, err := m.ReportDataProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvmClient(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BlockHeight != 0 {
		i = encodeVarintEvmClient(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockRelayProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRelayProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockRelayProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CommonVote) > 0 {
		i -= len(m.CommonVote)
		copy(dAtA[i:], m.CommonVote)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.CommonVote)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.HeaderHash) > 0 {
		i -= len(m.HeaderHash)
		copy(dAtA[i:], m.HeaderHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.HeaderHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AppHash) > 0 {
		i -= len(m.AppHash)
		copy(dAtA[i:], m.AppHash)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.AppHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvmClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.CommonEncodedVotePart.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvmClient(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.BlockHeaderMerkleParts.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvmClient(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.MultistoreProof.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvmClient(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReportDataProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportDataProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportDataProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerklePaths) > 0 {
		for iNdEx := len(m.MerklePaths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MerklePaths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvmClient(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Version != 0 {
		i = encodeVarintEvmClient(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Report.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvmClient(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.DataKey) > 0 {
		i -= len(m.DataKey)
		copy(dAtA[i:], m.DataKey)
		i = encodeVarintEvmClient(dAtA, i, uint64(len(m.DataKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvmClient(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvmClient(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IAVLMerklePathHex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsDataOnRight {
		n += 2
	}
	if m.SubtreeHeight != 0 {
		n += 1 + sovEvmClient(uint64(m.SubtreeHeight))
	}
	if m.SubtreeSize != 0 {
		n += 1 + sovEvmClient(uint64(m.SubtreeSize))
	}
	if m.SubtreeVersion != 0 {
		n += 1 + sovEvmClient(uint64(m.SubtreeVersion))
	}
	l = len(m.SiblingHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	return n
}

func (m *MulitstoreHex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LuqchainIavlStateHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = len(m.MintStoreMerkleHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = len(m.IcacontrollerToIcahostMerkleHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = len(m.FeegrantToIbcMerkleHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = len(m.AccToEvidenceMerkleHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = len(m.ParamsToVestingMerkleHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	return n
}

func (m *BlockHeaderHex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VersionChainidHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovEvmClient(uint64(m.Height))
	}
	if m.TimeSecond != 0 {
		n += 1 + sovEvmClient(uint64(m.TimeSecond))
	}
	if m.TimeNanosecond != 0 {
		n += 1 + sovEvmClient(uint64(m.TimeNanosecond))
	}
	l = len(m.LastblockidCommitHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = len(m.NextvalidatorConsensusHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = len(m.LastresultsHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = len(m.EvidenceProposerHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	return n
}

func (m *CommonHex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SignedDataPrefix)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = len(m.SignedDataSuffix)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	return n
}

func (m *TmSigHex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.R)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = len(m.S)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	if m.V != 0 {
		n += 1 + sovEvmClient(uint64(m.V))
	}
	l = len(m.EncodedTimestamp)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	return n
}

func (m *Report) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Qdata)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovEvmClient(uint64(m.Value))
	}
	if m.Timestamp != 0 {
		n += 1 + sovEvmClient(uint64(m.Timestamp))
	}
	return n
}

func (m *Proof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovEvmClient(uint64(m.BlockHeight))
	}
	if m.ReportDataProof != nil {
		l = m.ReportDataProof.Size()
		n += 1 + l + sovEvmClient(uint64(l))
	}
	if m.BlockRelayProof != nil {
		l = m.BlockRelayProof.Size()
		n += 1 + l + sovEvmClient(uint64(l))
	}
	return n
}

func (m *BlockRelayProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MultistoreProof.Size()
	n += 1 + l + sovEvmClient(uint64(l))
	l = m.BlockHeaderMerkleParts.Size()
	n += 1 + l + sovEvmClient(uint64(l))
	l = m.CommonEncodedVotePart.Size()
	n += 1 + l + sovEvmClient(uint64(l))
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovEvmClient(uint64(l))
		}
	}
	l = len(m.AppHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = len(m.HeaderHash)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = len(m.CommonVote)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	return n
}

func (m *ReportDataProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataKey)
	if l > 0 {
		n += 1 + l + sovEvmClient(uint64(l))
	}
	l = m.Report.Size()
	n += 1 + l + sovEvmClient(uint64(l))
	if m.Version != 0 {
		n += 1 + sovEvmClient(uint64(m.Version))
	}
	if len(m.MerklePaths) > 0 {
		for _, e := range m.MerklePaths {
			l = e.Size()
			n += 1 + l + sovEvmClient(uint64(l))
		}
	}
	return n
}

func sovEvmClient(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvmClient(x uint64) (n int) {
	return sovEvmClient(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IAVLMerklePathHex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvmClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IAVLMerklePathHex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IAVLMerklePathHex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDataOnRight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDataOnRight = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtreeHeight", wireType)
			}
			m.SubtreeHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubtreeHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtreeSize", wireType)
			}
			m.SubtreeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubtreeSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubtreeVersion", wireType)
			}
			m.SubtreeVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubtreeVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiblingHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiblingHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvmClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvmClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MulitstoreHex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvmClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MulitstoreHex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MulitstoreHex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LuqchainIavlStateHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LuqchainIavlStateHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintStoreMerkleHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintStoreMerkleHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcacontrollerToIcahostMerkleHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IcacontrollerToIcahostMerkleHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeegrantToIbcMerkleHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeegrantToIbcMerkleHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccToEvidenceMerkleHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccToEvidenceMerkleHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamsToVestingMerkleHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParamsToVestingMerkleHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvmClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvmClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockHeaderHex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvmClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockHeaderHex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockHeaderHex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionChainidHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionChainidHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSecond", wireType)
			}
			m.TimeSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeSecond |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeNanosecond", wireType)
			}
			m.TimeNanosecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeNanosecond |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastblockidCommitHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastblockidCommitHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextvalidatorConsensusHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextvalidatorConsensusHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastresultsHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastresultsHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceProposerHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceProposerHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvmClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvmClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonHex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvmClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonHex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonHex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedDataPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedDataPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedDataSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedDataSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvmClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvmClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TmSigHex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvmClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TmSigHex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TmSigHex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.R = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field S", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.S = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			m.V = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.V |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedTimestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedTimestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvmClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvmClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Report) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvmClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Report: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Report: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qdata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Qdata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvmClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvmClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvmClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportDataProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportDataProof == nil {
				m.ReportDataProof = &ReportDataProof{}
			}
			if err := m.ReportDataProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRelayProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockRelayProof == nil {
				m.BlockRelayProof = &BlockRelayProof{}
			}
			if err := m.BlockRelayProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvmClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvmClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRelayProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvmClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRelayProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRelayProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultistoreProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MultistoreProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeaderMerkleParts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockHeaderMerkleParts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonEncodedVotePart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommonEncodedVotePart.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, TmSigHex{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonVote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommonVote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvmClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvmClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportDataProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvmClient
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportDataProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportDataProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Report.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerklePaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvmClient
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvmClient
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerklePaths = append(m.MerklePaths, IAVLMerklePathHex{})
			if err := m.MerklePaths[len(m.MerklePaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvmClient(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvmClient
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvmClient(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvmClient
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvmClient
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvmClient
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvmClient
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvmClient
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvmClient        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvmClient          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvmClient = fmt.Errorf("proto: unexpected end of group")
)
